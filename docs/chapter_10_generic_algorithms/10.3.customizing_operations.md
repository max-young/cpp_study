<!-- TOC -->

- [10.3.1. Passing a Function to an Algorithm](#1031-passing-a-function-to-an-algorithm)
  - [Predicates断言](#predicates断言)
  - [Sorting Algorithms](#sorting-algorithms)
- [10.3.2. Lambda Expressions](#1032-lambda-expressions)
  - [Introducing Lambdas](#introducing-lambdas)
  - [Passing Arguments to a Lambda](#passing-arguments-to-a-lambda)
  - [Using the Capture List](#using-the-capture-list)
  - [Calling find_if](#calling-find_if)
  - [The for_each Algorithm](#the-for_each-algorithm)

<!-- /TOC -->

比较两个元素可以通过默认的operators: < > ==  
但是有些情况下这些默认的比较运算符不够用, 比如sort比较复杂的objects, 他们不能用这些默认operators, 或者比较objects里的元素, 那我们就只能自定义了.

<a id="markdown-1031-passing-a-function-to-an-algorithm" name="1031-passing-a-function-to-an-algorithm"></a>
#### 10.3.1. Passing a Function to an Algorithm

<a id="markdown-predicates断言" name="predicates断言"></a>
##### Predicates断言

predicate断言是一个expression, 可以被执行并且返回值能作为condition. 他可以是一个函数.  
unary predicate用一个参数  
binary predicate用两个参数 

例如sort可以传一个自定义predicate  
对于10.2章节的代码, 可以继续修改:  
```cpp
bool isShorter(const string& s1, const string& s2) {
  return s1.size() < s2.size();
}
sort(text.begin(), text.end(), isShorter);
```

<a id="markdown-sorting-algorithms" name="sorting-algorithms"></a>
##### Sorting Algorithms

上面的sort algorithm传入了isShorter函数, 这样就按单词长短排序.  
但是如果两个单词长度相等的话, 我们还想按字母排序, 那么可以用*stable_sort* algorithm
```cpp
elimDump(text);
stable_sort(text.begin(), text.end(), isShorter);
```

<a href="code/chapter_10_generic_algorithms/10.3.stable_sort.cpp">完整代码</a>

partion algorithm可以传入一个predicate, 会把container分成两个部分, 第一部分满足条件, 第二部分不满足, 返回第一部分的最后一个迭代器. <a href="code/chapter_10_generic_algorithms/10.3.1.partition.cpp">示例代码</a>

<a id="markdown-1032-lambda-expressions" name="1032-lambda-expressions"></a>
#### 10.3.2. Lambda Expressions

<a id="markdown-introducing-lambdas" name="introducing-lambdas"></a>
##### Introducing Lambdas

除了function可以被调用, lambda expression也可以.  
lambda expression可以看作是没有名称的inline function, 它和function一样, 有参数有函数体有返回值, 但是它只能在function内部定义.  
它的格式是:  
[capture list](parameter list)->return type{function body};  
capture list是指其所在的function里的局部变量, 通常为空, 但是中括号不能省略.  
parameter list如果为空, 小括号可以省略.  
一个简单的例子:  
```cpp
auto f = []{return 42;};
cout << f() << endl;
```
lambda expression f的capture list为空, 也没有parameter list.

<a id="markdown-passing-arguments-to-a-lambda" name="passing-arguments-to-a-lambda"></a>
##### Passing Arguments to a Lambda

之前我们定义了一个简单的判定一个string的size是否大于4的函数:
```cpp
bool longerThan4(const std::string &s)
{
  return s.size() >= 4;
}
```
我们可以用lambda expression来替换这个函数:
```cpp
[](const std::string &s) {return s1.size() >= 4;}
```
我们把这个lambda expression传入的partition函数里:
```cpp
partition(text.begin(), text.end(),
  [](const std::string &s) {return s1.size() >= 4;}
);
```

<a id="markdown-using-the-capture-list" name="using-the-capture-list"></a>
##### Using the Capture List

上面的capture list为空, 我们把要判定的size拿出来放到capture list里面:
```cpp
[sz](const std::string &s) {return s1.size() >= sz;}
```

<a id="markdown-calling-find_if" name="calling-find_if"></a>
##### Calling find_if

find_if和find不一样, find是指找到container里面某个元素的index, find＿if是指找到container里符合某个condition的元素的iterator:
```cpp
auto ind = find_if(text.begin(), text.end(),
  [](const std::string &s) {
    return s.size() >= 5;
  }
);
```
在这里size是写死的5, 我们可不可以自定义? 这就用到上面的capture list了, 我们把这些操作放到一个叫做printLongerWords的函数里, size作为参数, 就实现了

<a id="markdown-the-for_each-algorithm" name="the-for_each-algorithm"></a>
##### The for_each Algorithm

上面find_if找到了第一个符合条件的iterator, 我们可以用for_each来把size>=5的elements都输出:
```cpp
for_each(ind, text.end(), [](const std::string &s) {
  std::cout << s << " ";
});
```

<a href="code/chapter_10_generic_algorithms/10.3.2.lambda_expression.cpp">完整代码</a>

<a href="code/chapter_10_generic_algorithms/10.3.2.exercise.cpp">练习代码</a>

