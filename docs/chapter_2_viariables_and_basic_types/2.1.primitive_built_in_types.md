<!-- TOC -->

- [2.1.1 Arithmetic Types](#211-arithmetic-types)
- [2.1.3. Literals字面量](#213-literals字面量)

<!-- /TOC -->

<a id="markdown-211-arithmetic-types" name="211-arithmetic-types"></a>
#### 2.1.1 Arithmetic Types

**Signed and Unsigned Types**

unsigned是unsigned int的简写.  
int和unsigned int不要混用.
```cpp
unsigned u = 10;
int i = -42;
cout << i + u << endl;  // i+u是unsigned int, 会输出4294967264(if 32bit)
```

<a id="markdown-213-literals字面量" name="213-literals字面量"></a>
#### 2.1.3. Literals字面量

我们说`3.14`是一个literal字面量, 因为它的值是不言而喻的, 一个literal的form和value决定了其类型.  

**Integer and Floating-Point Literals**

定义float变量我看到两种写法:  
```cpp
float a = 3.14;
float b = 3.14f;
```
suffix后缀f表示什么意思?  
这两种写法有什么区别?  

先说答案:  
suffix f表示float类型, 不加默认是double类型.  
也就是说`3.14`是double类型, `3.14f`是float类型.   
所以a和b都等于`3.14f`, 而不等于`3.14`.    
因为a和b定义的类型都是float, 所以后面的赋值3.14的suffix是否加f, 结果都是一样的.  
第一种写法应该会有类型转换, 所以推荐第二种写法.

floating-point小数literal默认是double类型, 加上不同的suffix可以表示不同的类型, 如下图:  
<img src="_images/literal_types.png">  
可以看到suffix后面加f和F是一样的, 都表示float类型.

对于integer, 前缀0代表octal八进制, 0x代表hexadecimal十六进制, 数字20可以表示为:  
`20 024 0x14`

**Character and Character String Literals**

单引号代表char字符 literal  
双引号代表string字符串 literal  

string literal就是a list of char, 编译器会在句尾会加上"\0"(null).  
所以'a'有一个字符, "a"有两个字符.  

对于太长的一段文字, 可以有多个string literals来表示:
```cpp
std::cout << "a really really long string literals"
            "that spans two lines" << std::endl;
```

**Escape Sequences**

有些字符是没有显示的, 比如缩进、换行等, 他们可以用backslash来表示